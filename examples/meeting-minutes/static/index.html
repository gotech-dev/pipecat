<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Minutes - Ghi √¢m & D·ªãch Realtime</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        select, button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        select {
            background: white;
            border: 2px solid #dee2e6;
            flex: 1;
            min-width: 200px;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #28a745;
            color: white;
            font-weight: 600;
            min-width: 180px;
        }

        button:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        button.recording {
            background: #dc3545;
        }

        button.recording:hover {
            background: #c82333;
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status.recording {
            display: block;
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .transcripts {
            padding: 30px;
            max-height: 600px;
            overflow-y: auto;
            background: white;
        }

        .transcript-item {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .transcript-item.translation {
            border-left-color: #28a745;
            background: #d4edda;
            margin-left: 30px;
        }

        .transcript-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
        }

        .transcript-text {
            font-size: 18px;
            line-height: 1.6;
            color: #212529;
        }

        .transcript-text.original {
            font-weight: 500;
        }

        .transcript-text.translation {
            color: #155724;
        }

        .transcript-timestamp {
            font-size: 11px;
            color: #adb5bd;
            margin-top: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .empty-state-text {
            font-size: 18px;
        }

        /* Scrollbar styling */
        .transcripts::-webkit-scrollbar {
            width: 8px;
        }

        .transcripts::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .transcripts::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .transcripts::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéôÔ∏è Meeting Minutes</h1>
            <p>Ghi √¢m v√† d·ªãch realtime cu·ªôc h·ªçp</p>
            <button onclick="handleLogout()" style="position: absolute; top: 20px; right: 20px; background: rgba(255, 255, 255, 0.2); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">ƒêƒÉng xu·∫•t</button>
        </div>

        <div class="controls">
            <div class="control-group">
                <select id="language">
                    <option value="ja">üáØüáµ Ti·∫øng Nh·∫≠t</option>
                    <option value="en">üá¨üáß Ti·∫øng Anh</option>
                </select>
                <button id="recordBtn" onclick="toggleRecording()">‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu ghi √¢m</button>
                <a href="/history" style="text-decoration: none;">
                    <button id="historyBtn" style="background: #6c757d;">üìö L·ªãch s·ª≠</button>
                </a>
            </div>
            <div class="status" id="status"></div>
        </div>

        <div class="transcripts" id="transcripts">
            <div class="empty-state">
                <div class="empty-state-icon">üé§</div>
                <div class="empty-state-text">Ch·ªçn ng√¥n ng·ªØ v√† b·∫•m "B·∫Øt ƒë·∫ßu ghi √¢m" ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
            </div>
        </div>
    </div>

    <script>
        let isRecording = false;
        let ws = null;
        let transcriptCount = 0;
        let pc = null; // RTCPeerConnection
        let localStream = null;
        let lastIceStats = null; // Store last ICE stats for debugging
        
        // Global function to check ICE candidates (for debugging)
        async function checkIceCandidates() {
            if (!pc) {
                console.warn('‚ö†Ô∏è No WebRTC connection available');
                if (lastIceStats) {
                    console.log('üìã Last saved ICE stats:', lastIceStats);
                }
                return;
            }
            try {
                const stats = await pc.getStats();
                const candidates = [];
                const candidatePairs = [];
                
                stats.forEach(report => {
                    if (report.type === 'local-candidate' || report.type === 'remote-candidate') {
                        candidates.push({
                            type: report.type,
                            candidateType: report.candidateType,
                            protocol: report.protocol,
                            ip: report.ip || report.address,
                            port: report.port,
                            priority: report.priority
                        });
                    }
                    if (report.type === 'candidate-pair') {
                        candidatePairs.push({
                            localCandidateId: report.localCandidateId,
                            remoteCandidateId: report.remoteCandidateId,
                            state: report.state,
                            selected: report.selected,
                            localCandidateType: report.localCandidateType,
                            remoteCandidateType: report.remoteCandidateType
                        });
                    }
                });
                
                console.log('üìä ICE Candidates:', candidates);
                console.log('üìä Candidate Pairs:', candidatePairs);
                
                // Detailed candidate info
                console.log('üìã Detailed Candidates:');
                candidates.forEach((c, i) => {
                    console.log(`  ${i+1}. ${c.type} - Type: ${c.candidateType}, Protocol: ${c.protocol}, IP: ${c.ip}, Port: ${c.port}`);
                });
                
                // Detailed candidate pairs info
                console.log('üìã Detailed Candidate Pairs:');
                candidatePairs.forEach((pair, i) => {
                    console.log(`  ${i+1}. State: ${pair.state}, Selected: ${pair.selected}, Local: ${pair.localCandidateType}, Remote: ${pair.remoteCandidateType}`);
                });
                
                const selectedPair = candidatePairs.find(pair => pair.selected);
                if (selectedPair) {
                    console.log('‚úÖ Selected candidate pair:', selectedPair);
                    console.log('Local type:', selectedPair.localCandidateType);
                    console.log('Remote type:', selectedPair.remoteCandidateType);
                } else {
                    console.warn('‚ö†Ô∏è No candidate pair selected yet');
                    // Check why no pair is selected
                    const failedPairs = candidatePairs.filter(p => p.state === 'failed');
                    const inProgressPairs = candidatePairs.filter(p => p.state === 'in-progress');
                    const waitingPairs = candidatePairs.filter(p => p.state === 'waiting');
                    if (failedPairs.length > 0) {
                        console.error('‚ùå Failed pairs:', failedPairs.length);
                    }
                    if (inProgressPairs.length > 0) {
                        console.log('‚è≥ In-progress pairs:', inProgressPairs.length);
                    }
                    if (waitingPairs.length > 0) {
                        console.log('‚è≥ Waiting pairs:', waitingPairs.length);
                    }
                }
                
                // Check if TURN (relay) is being used
                const relayCandidates = candidates.filter(c => c.candidateType === 'relay');
                const srflxCandidates = candidates.filter(c => c.candidateType === 'srflx');
                const hostCandidates = candidates.filter(c => c.candidateType === 'host');
                
                console.log(`üìä Candidate Summary: Host: ${hostCandidates.length}, STUN (srflx): ${srflxCandidates.length}, TURN (relay): ${relayCandidates.length}`);
                
                if (relayCandidates.length > 0) {
                    console.log('‚úÖ TURN (relay) candidates found:', relayCandidates.length);
                    console.log('TURN candidates:', relayCandidates);
                } else {
                    console.warn('‚ö†Ô∏è No TURN (relay) candidates - TURN server may not be working');
                }
                
                if (srflxCandidates.length > 0) {
                    console.log('‚ÑπÔ∏è STUN (srflx) candidates found:', srflxCandidates.length);
                }
                
                // Save stats for later inspection
                lastIceStats = {
                    candidates,
                    candidatePairs,
                    selectedPair,
                    relayCandidates: relayCandidates.length,
                    srflxCandidates: srflxCandidates.length,
                    hostCandidates: hostCandidates.length
                };
                
                // Also get detailed stats
                try {
                    const detailedStats = await pc.getStats();
                    const detailedCandidates = [];
                    const detailedPairs = [];
                    
                    detailedStats.forEach(report => {
                        if (report.type === 'local-candidate' || report.type === 'remote-candidate') {
                            detailedCandidates.push({
                                type: report.type,
                                candidateType: report.candidateType,
                                protocol: report.protocol,
                                ip: report.ip || report.address,
                                port: report.port,
                                priority: report.priority,
                                url: report.url
                            });
                        }
                        if (report.type === 'candidate-pair') {
                            detailedPairs.push({
                                state: report.state,
                                selected: report.selected,
                                localCandidateType: report.localCandidateType,
                                remoteCandidateType: report.remoteCandidateType,
                                availableOutgoingBitrate: report.availableOutgoingBitrate,
                                availableIncomingBitrate: report.availableIncomingBitrate,
                                bytesReceived: report.bytesReceived,
                                bytesSent: report.bytesSent
                            });
                        }
                    });
                    
                    console.log('üîç Detailed ICE Stats:');
                    console.log('  Candidates:', detailedCandidates);
                    console.log('  Pairs:', detailedPairs);
                    
                    lastIceStats.detailedCandidates = detailedCandidates;
                    lastIceStats.detailedPairs = detailedPairs;
                } catch (err) {
                    console.warn('Could not get detailed stats:', err);
                }
            } catch (error) {
                console.error('Error checking ICE candidates:', error);
            }
        }
        
        // Function to view last saved stats
        function viewLastIceStats() {
            if (lastIceStats) {
                console.log('üìã Last ICE Stats:', lastIceStats);
                return lastIceStats;
            } else {
                console.warn('‚ö†Ô∏è No saved ICE stats available');
                return null;
            }
        }
        
        // Session boxes - reset when starting new recording
        let sessionTranscriptBox = null;
        let sessionTranslationBox = null;

        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const lang = document.getElementById('language').value;
            const status = document.getElementById('status');
            const transcripts = document.getElementById('transcripts');

            if (!isRecording) {
                // Start recording
                try {
                    const response = await fetch('/api/start-recording', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({language: lang})
                    });

                    if (!response.ok) {
                        throw new Error('Failed to start recording');
                    }

                    // Connect WebSocket
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/transcripts`;
                    ws = new WebSocket(wsUrl);

                    ws.onopen = async () => {
                        console.log('‚úÖ WebSocket connected for transcripts');
                        // Now connect to WebRTC to start audio input
                        try {
                            await connectWebRTC();
                        } catch (error) {
                            console.error('WebRTC connection failed:', error);
                            alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi microphone. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p.');
                            // Reset UI on error
                            btn.textContent = '‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu ghi √¢m';
                            btn.classList.remove('recording');
                            isRecording = false;
                        }
                    };

                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        console.log('üì® Received transcript:', data);
                        addTranscript(data);
                    };

                    ws.onerror = (error) => {
                        console.error('‚ùå WebSocket error:', error);
                        alert('L·ªói k·∫øt n·ªëi WebSocket. Vui l√≤ng th·ª≠ l·∫°i.');
                    };

                    ws.onclose = () => {
                        console.log('WebSocket disconnected');
                    };

                    // Update UI
                    btn.textContent = '‚èπÔ∏è D·ª´ng ghi √¢m';
                    btn.classList.add('recording');
                    status.textContent = `üî¥ ƒêang ghi √¢m - Ng√¥n ng·ªØ: ${lang === 'ja' ? 'Ti·∫øng Nh·∫≠t' : 'Ti·∫øng Anh'}`;
                    status.classList.add('recording');
                    
                    // Clear empty state
                    if (transcriptCount === 0) {
                        transcripts.innerHTML = '';
                    }
                    
                    // Reset session boxes for new recording
                    sessionTranscriptBox = null;
                    sessionTranslationBox = null;

                    isRecording = true;
                } catch (error) {
                    alert('L·ªói khi b·∫Øt ƒë·∫ßu ghi √¢m: ' + error.message);
                    console.error(error);
                }
            } else {
                // Stop recording
                try {
                    await fetch('/api/stop-recording', {method: 'POST'});
                    
                    // Disconnect WebRTC
                    disconnectWebRTC();
                    
                    if (ws) {
                        ws.close();
                        ws = null;
                    }

                    btn.textContent = '‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu ghi √¢m';
                    btn.classList.remove('recording');
                    status.textContent = '‚úÖ ƒê√£ d·ª´ng ghi √¢m';
                    status.classList.remove('recording');
                    
                    setTimeout(() => {
                        status.style.display = 'none';
                    }, 3000);

                    isRecording = false;
                } catch (error) {
                    alert('L·ªói khi d·ª´ng ghi √¢m: ' + error.message);
                    console.error(error);
                }
            }
        }

        function addTranscript(data) {
            const transcripts = document.getElementById('transcripts');
            
            // Remove empty state if first transcript
            if (transcriptCount === 0 && transcripts.querySelector('.empty-state')) {
                transcripts.innerHTML = '';
            }

            if (data.type === 'transcription') {
                // Create session transcript box if not exists
                if (!sessionTranscriptBox) {
                    const langLabel = data.language ? data.language.toUpperCase() : 'JA';
                    sessionTranscriptBox = document.createElement('div');
                    sessionTranscriptBox.className = 'transcript-item';
                    sessionTranscriptBox.innerHTML = `
                        <div class="transcript-label">üìù B·∫¢N G·ªêC (${langLabel})</div>
                        <div class="transcript-text original"></div>
                        <div class="transcript-timestamp"></div>
                    `;
                    
                    // Insert at the beginning
                    if (transcripts.firstChild) {
                        transcripts.insertBefore(sessionTranscriptBox, transcripts.firstChild);
                    } else {
                        transcripts.appendChild(sessionTranscriptBox);
                    }
                }
                
                // Append text to the box
                const textDiv = sessionTranscriptBox.querySelector('.transcript-text');
                const timestampDiv = sessionTranscriptBox.querySelector('.transcript-timestamp');
                
                if (textDiv.textContent.trim()) {
                    textDiv.textContent += ' ' + data.text;
                } else {
                    textDiv.textContent = data.text;
                }
                timestampDiv.textContent = formatTimestamp(data.timestamp);
                
            } else if (data.type === 'translation') {
                // Create session translation box if not exists
                if (!sessionTranslationBox) {
                    sessionTranslationBox = document.createElement('div');
                    sessionTranslationBox.className = 'transcript-item translation';
                    sessionTranslationBox.innerHTML = `
                        <div class="transcript-label">üåê B·∫¢N D·ªäCH (TI·∫æNG VI·ªÜT)</div>
                        <div class="transcript-text translation"></div>
                        <div class="transcript-timestamp"></div>
                    `;
                    
                    // Insert after transcript box if exists, otherwise at beginning
                    if (sessionTranscriptBox && transcripts.contains(sessionTranscriptBox)) {
                        if (sessionTranscriptBox.nextSibling) {
                            transcripts.insertBefore(sessionTranslationBox, sessionTranscriptBox.nextSibling);
                        } else {
                            transcripts.appendChild(sessionTranslationBox);
                        }
                    } else if (transcripts.firstChild) {
                        transcripts.insertBefore(sessionTranslationBox, transcripts.firstChild);
                    } else {
                        transcripts.appendChild(sessionTranslationBox);
                    }
                }
                
                // Append text to the box
                const textDiv = sessionTranslationBox.querySelector('.transcript-text');
                const timestampDiv = sessionTranslationBox.querySelector('.transcript-timestamp');
                
                if (textDiv.textContent.trim()) {
                    textDiv.textContent += ' ' + data.text;
                } else {
                    textDiv.textContent = data.text;
                }
                timestampDiv.textContent = formatTimestamp(data.timestamp);
            }
            
            // Scroll to top to see latest content
            transcripts.scrollTop = 0;
            transcriptCount++;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('vi-VN');
            } catch {
                return '';
            }
        }

        async function connectWebRTC() {
            try {
                console.log('üîó Connecting WebRTC...');
                
                // Get user media (microphone)
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: false 
                });
                console.log('‚úÖ Microphone access granted');
                
                // Create RTCPeerConnection with STUN and TURN servers
                // TURN server is needed when STUN alone cannot establish connection (behind NAT/firewall)
                // Using self-hosted TURN server for better reliability
                const TURN_SERVER_IP = '116.118.2.69'; // Server public IP
                const TURN_USERNAME = 'turnuser';
                const TURN_PASSWORD = 'turnpassword123';
                
                pc = new RTCPeerConnection({
                    iceServers: [
                        // STUN servers - helps discover public IP/port
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        // Self-hosted TURN server (primary)
                        { 
                            urls: `turn:${TURN_SERVER_IP}:3478`,
                            username: TURN_USERNAME,
                            credential: TURN_PASSWORD
                        },
                        { 
                            urls: `turn:${TURN_SERVER_IP}:3478?transport=tcp`,
                            username: TURN_USERNAME,
                            credential: TURN_PASSWORD
                        },
                        // Fallback: Free public TURN servers (backup)
                        { 
                            urls: 'turn:openrelay.metered.ca:80',
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        },
                        { 
                            urls: 'turn:openrelay.metered.ca:443',
                            username: 'openrelayproject',
                            credential: 'openrelayproject'
                        }
                    ],
                    // Increase ICE candidate gathering timeout
                    iceCandidatePoolSize: 10
                });
                
                // Add audio track
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
                
                // Handle ICE candidates
                // Queue candidates until we have the server's pc_id
                let serverPcId = null;
                const iceCandidatesQueue = [];
                
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const candidateData = {
                            candidate: event.candidate.candidate,
                            sdp_mline_index: event.candidate.sdpMLineIndex !== null && event.candidate.sdpMLineIndex !== undefined 
                                ? event.candidate.sdpMLineIndex 
                                : 0,
                            sdp_mid: event.candidate.sdpMid || ""
                        };

                        if (serverPcId) {
                            // If we already have pc_id, send immediately
                            sendIceCandidate(serverPcId, candidateData);
                        } else {
                            // Otherwise queue it
                            console.log('‚è≥ Queueing ICE candidate (waiting for pc_id)');
                            iceCandidatesQueue.push(candidateData);
                        }
                    }
                };
                
                // Helper to send ICE candidate
                function sendIceCandidate(pcId, candidateData) {
                    const candidatePayload = {
                        pc_id: pcId,
                        candidates: [candidateData]
                    };
                    
                    fetch('/api/offer', {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(candidatePayload)
                    }).catch(err => console.error('‚ùå ICE candidate error:', err));
                }

                // Handle connection state
                pc.onconnectionstatechange = () => {
                    console.log('WebRTC connection state:', pc.connectionState);
                    if (pc.connectionState === 'connected') {
                        console.log('‚úÖ WebRTC connected - Ready to receive audio');
                    } else if (pc.connectionState === 'failed') {
                        console.error('‚ùå WebRTC connection failed');
                        // Try to restart connection
                        setTimeout(() => {
                            console.log('üîÑ Attempting to reconnect...');
                            disconnectWebRTC();
                            connectWebRTC().catch(err => console.error('Reconnection error:', err));
                        }, 2000);
                    } else if (pc.connectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è WebRTC disconnected');
                    }
                };
                
                // Handle ICE connection state (more detailed)
                pc.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', pc.iceConnectionState);
                    if (pc.iceConnectionState === 'failed') {
                        console.error('‚ùå ICE connection failed - May need TURN server');
                        // Debug: Check all candidates
                        setTimeout(() => checkIceCandidates(), 1000);
                    } else if (pc.iceConnectionState === 'connected') {
                        console.log('‚úÖ ICE connection established');
                        setTimeout(() => checkIceCandidates(), 1000);
                    } else if (pc.iceConnectionState === 'checking') {
                        console.log('üîç ICE connection checking...');
                        // Check candidates after 2 seconds of checking
                        setTimeout(() => checkIceCandidates(), 2000);
                    } else if (pc.iceConnectionState === 'disconnected') {
                        console.warn('‚ö†Ô∏è ICE connection disconnected');
                        checkIceCandidates();
                    }
                };
                
                // Handle ICE gathering state
                pc.onicegatheringstatechange = () => {
                    console.log('ICE gathering state:', pc.iceGatheringState);
                    if (pc.iceGatheringState === 'complete') {
                        console.log('‚úÖ ICE gathering complete');
                        setTimeout(() => checkIceCandidates(), 500);
                    }
                };
                
                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Send offer to server
                const offerPayload = {
                    sdp: offer.sdp,
                    type: offer.type,
                    pc_id: 'meeting-minutes-pc'
                };
                
                console.log('üì§ Sending WebRTC offer:', { type: offerPayload.type, sdp_length: offerPayload.sdp.length });
                
                const response = await fetch('/api/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(offerPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå WebRTC offer failed:', response.status, errorText);
                    throw new Error(`Failed to connect WebRTC: ${response.status} - ${errorText}`);
                }
                
                const answer = await response.json();
                console.log('üì• Received WebRTC answer:', { type: answer.type, pc_id: answer.pc_id });
                
                if (!answer.sdp || !answer.type) {
                    throw new Error('Invalid answer from server');
                }
                
                // Store pc_id from server
                serverPcId = answer.pc_id;
                pc.pc_id = serverPcId; 
                
                // Flush queued candidates
                if (iceCandidatesQueue.length > 0) {
                    console.log(`üì§ Flushing ${iceCandidatesQueue.length} queued ICE candidates`);
                    iceCandidatesQueue.forEach(candidate => sendIceCandidate(serverPcId, candidate));
                    iceCandidatesQueue.length = 0; // Clear queue
                }
                
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: answer.type,
                    sdp: answer.sdp
                }));
                
                console.log('‚úÖ WebRTC offer/answer exchange complete');
                
            } catch (error) {
                console.error('‚ùå WebRTC connection error:', error);
                alert('L·ªói k·∫øt n·ªëi microphone: ' + error.message);
                // Cleanup on error
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                if (pc) {
                    pc.close();
                }
                throw error;
            }
        }
        
        function disconnectWebRTC() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            console.log('üîå WebRTC disconnected');
        }

        // Disable language selection when recording
        document.getElementById('language').addEventListener('change', function() {
            if (isRecording) {
                this.disabled = true;
            } else {
                this.disabled = false;
            }
        });

        // Logout function
        async function handleLogout() {
            try {
                const response = await fetch('/api/logout', {
                    method: 'POST',
                    credentials: 'include'
                });
                if (response.ok) {
                    window.location.href = '/';
                }
            } catch (error) {
                console.error('Logout error:', error);
                // Redirect anyway
                window.location.href = '/';
            }
        }
    </script>
</body>
</html>

